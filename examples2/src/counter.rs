use odra2::prelude::*;
use odra2::types::{runtime_args, FromBytes, RuntimeArgs};
use odra2::{CallDef, ContractEnv, HostEnv, Mapping, Variable};

pub struct Counter {
    env: Rc<ContractEnv>,
    count0: Variable<0, u32>,
    count1: Variable<1, u32>,
    count2: Variable<2, u32>,
    count3: Variable<3, u32>,
    count4: Variable<4, u32>,
    count5: Variable<5, u32>,
    count6: Variable<6, u32>,
    count7: Variable<7, u32>,
    count8: Variable<8, u32>,
    count9: Variable<9, u32>,
    counts: Mapping<10, u8, u32>
}

// Autogenerated
pub struct CounterRef {
    address: Address,
    env: RefCell<HostEnv>
}

impl CounterRef {
    pub fn get_count(&self, index: u8) -> u32 {
        let mut args = runtime_args! {};
        args.insert("index", index).unwrap();
        let call_def = CallDef::new("get_count".to_string(), args, None);
        let result = self.env.borrow_mut().call_contract(&self.address, call_def);
        let result = u32::from_bytes(result.as_slice()).unwrap();
        result.0
    }

    pub fn increment(&mut self, index: u8) {
        let mut args = runtime_args! {};
        args.insert("index", index).unwrap();
        let call_def = CallDef::new("increment".to_string(), args, None);
        self.env.borrow_mut().call_contract(&self.address, call_def);
    }
}

impl Counter {
    pub fn get_count(&self, index: u8) -> u32 {
        match index {
            0 => self.count0.get_or_default(),
            1 => self.count1.get_or_default(),
            2 => self.count2.get_or_default(),
            3 => self.count3.get_or_default(),
            4 => self.count4.get_or_default(),
            5 => self.count5.get_or_default(),
            6 => self.count6.get_or_default(),
            7 => self.count7.get_or_default(),
            8 => self.count8.get_or_default(),
            9 => self.count9.get_or_default(),
            _ => unreachable!()
        }
        // self.counts.get_or_default(index)
    }

    pub fn increment(&mut self, index: u8) {
        match index {
            0 => increment(&mut self.count0),
            1 => increment(&mut self.count1),
            2 => increment(&mut self.count2),
            3 => increment(&mut self.count3),
            4 => increment(&mut self.count4),
            5 => increment(&mut self.count5),
            6 => increment(&mut self.count6),
            7 => increment(&mut self.count7),
            8 => increment(&mut self.count8),
            9 => increment(&mut self.count9),
            _ => unreachable!()
        };
        // let count = self.counts.get_or_default(index);
        // self.counts.set(index, count + 1);
    }
}

fn increment<const N: u8>(count: &mut Variable<N, u32>) {
    let a = count.get_or_default();
    count.set(a + 1);
}

mod odra_core_module {
    use super::*;
    impl odra2::module::Module for Counter {
        fn new(env: Rc<ContractEnv>) -> Self {
            let count0 = Variable::new(Rc::clone(&env));
            let count1 = Variable::new(Rc::clone(&env));
            let count2 = Variable::new(Rc::clone(&env));
            let count3 = Variable::new(Rc::clone(&env));
            let count4 = Variable::new(Rc::clone(&env));
            let count5 = Variable::new(Rc::clone(&env));
            let count6 = Variable::new(Rc::clone(&env));
            let count7 = Variable::new(Rc::clone(&env));
            let count8 = Variable::new(Rc::clone(&env));
            let count9 = Variable::new(Rc::clone(&env));
            let counts = Mapping::new(Rc::clone(&env));
            Self {
                env,
                count0,
                count1,
                count2,
                count3,
                count4,
                count5,
                count6,
                count7,
                count8,
                count9,
                counts
            }
        }

        fn env(&self) -> &ContractEnv {
            &self.env
        }
    }
}

// autogenerated
#[cfg(odra_module = "Counter")]
#[cfg(target_arch = "wasm32")]
mod wasm_parts {
    use super::Counter;
    use odra2::module::Module;
    use odra2::odra_casper_backend2;
    use odra2::odra_casper_backend2::casper_contract::unwrap_or_revert::UnwrapOrRevert;
    use odra2::odra_casper_backend2::casper_contract_env::WasmContractEnv;
    use odra2::types::casper_types::{
        CLType, CLValue, EntryPoint, EntryPointAccess, EntryPointType, EntryPoints, Parameter
    };
    use odra2::{prelude::*, ContractEnv};
    use odra_casper_backend2::casper_contract::contract_api::runtime;
    extern crate alloc;

    fn entry_points() -> EntryPoints {
        let mut entry_points = EntryPoints::new();
        entry_points.add_entry_point(EntryPoint::new(
            "get_count",
            alloc::vec![Parameter::new("index", CLType::U8),],
            CLType::U32,
            EntryPointAccess::Public,
            EntryPointType::Contract
        ));
        entry_points.add_entry_point(EntryPoint::new(
            "increment",
            alloc::vec![Parameter::new("index", CLType::U8),],
            CLType::Unit,
            EntryPointAccess::Public,
            EntryPointType::Contract
        ));
        entry_points
    }

    pub fn execute_call() {
        odra_casper_backend2::wasm_host::install_contract(entry_points(), Vec::new());
    }

    pub fn execute_get_count() -> ! {
        let index: u8 = runtime::get_named_arg("index");
        let env = WasmContractEnv::new();
        let contract: Counter = Counter::new(Rc::new(env));
        let result = contract.get_count(index);
        runtime::ret(CLValue::from_t(result).unwrap_or_revert())
    }

    pub fn execute_increment() -> ! {
        let index: u8 = runtime::get_named_arg("index");
        let env = WasmContractEnv::new();
        let mut contract: Counter = Counter::new(Rc::new(env));
        contract.increment(index);
        runtime::ret(CLValue::from_t(()).unwrap_or_revert())
    }
}

// autogenerated
#[cfg(odra_module = "Counter")]
#[cfg(target_arch = "wasm32")]
mod wasm_exports {
    use super::wasm_parts;

    #[no_mangle]
    fn call() {
        wasm_parts::execute_call();
    }

    #[no_mangle]
    fn get_count() {
        wasm_parts::execute_get_count();
    }

    #[no_mangle]
    fn increment() {
        wasm_parts::execute_increment();
    }
}

#[cfg(not(target_arch = "wasm32"))]
mod casper_tests {
    use crate::counter::CounterRef;
    use core::cell::RefCell;
    use odra2::types::{runtime_args, RuntimeArgs};
    use odra2::HostEnv;

    pub struct CounterDeployer;

    impl CounterDeployer {
        pub fn new_contract(env: &mut HostEnv) -> CounterRef {
            let address = env.new_contract("counter", &runtime_args! {}, None);

            CounterRef {
                address,
                env: RefCell::new(env.clone_empty())
            }
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub use casper_tests::*;
use odra2::types::Address;

#[cfg(test)]
mod tests {
    use super::CounterDeployer;

    #[test]
    fn counter_works() {
        let mut env = odra2::test_env();
        let mut counter = CounterDeployer::new_contract(&mut env);
        assert_eq!(counter.get_count(0), 0);
        counter.increment(0);
        assert_eq!(counter.get_count(0), 1);
        counter.increment(1);
        counter.increment(1);
        assert_eq!(counter.get_count(1), 2);
    }
}
