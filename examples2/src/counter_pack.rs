extern crate alloc;

use alloc::rc::Rc;
use crate::counter::Counter;
use odra_core::{env::ContractEnv, module::ModuleWrapper, mapping::Mapping};

pub struct CounterPack {
    env: Rc<ContractEnv>,
    counter0: ModuleWrapper<0, Counter>,
    counter1: ModuleWrapper<1, Counter>,
    counter2: ModuleWrapper<2, Counter>,
    counter3: ModuleWrapper<3, Counter>,
    counter4: ModuleWrapper<4, Counter>,
    counter5: ModuleWrapper<5, Counter>,
    counter6: ModuleWrapper<6, Counter>,
    counter7: ModuleWrapper<7, Counter>,
    counter8: ModuleWrapper<8, Counter>,
    counter9: ModuleWrapper<9, Counter>,
    counters: Mapping<10, (u8, u8), u32>,
    counters_map: Mapping<11, u8, Counter>
}

impl CounterPack {
    pub fn get_count(&self, index_a: u8, index_b: u8) -> u32 {
        // match index_a {
        //     0 => self.counter0.get_count(index_b),
        //     1 => self.counter1.get_count(index_b),
        //     2 => self.counter2.get_count(index_b),
        //     3 => self.counter3.get_count(index_b),
        //     4 => self.counter4.get_count(index_b),
        //     5 => self.counter5.get_count(index_b),
        //     6 => self.counter6.get_count(index_b),
        //     7 => self.counter7.get_count(index_b),
        //     8 => self.counter8.get_count(index_b),
        //     9 => self.counter9.get_count(index_b),
        //     _ => unreachable!(),
        // }
        // self.counters.get_or_default((index_a, index_b))
        self.counters_map.module(index_a).get_count(index_b)
    }

    pub fn increment(&mut self, index_a: u8, index_b: u8) {
        // match index_a {
        //     0 => self.counter0.increment(index_b),
        //     1 => self.counter1.increment(index_b),
        //     2 => self.counter2.increment(index_b),
        //     3 => self.counter3.increment(index_b),
        //     4 => self.counter4.increment(index_b),
        //     5 => self.counter5.increment(index_b),
        //     6 => self.counter6.increment(index_b),
        //     7 => self.counter7.increment(index_b),
        //     8 => self.counter8.increment(index_b),
        //     9 => self.counter9.increment(index_b),
        //     _ => unreachable!(),
        // };
        // let count = self.counters.get_or_default((index_a, index_b));
        // self.counters.set((index_a, index_b), count + 1);
        self.counters_map.module(index_a).increment(index_b);
    }
}

// autogenerated
mod odra_core_module {
    use super::*;

    impl odra_core::module::Module for CounterPack {
        fn new(env: Rc<ContractEnv>) -> Self {
            let counter0 = ModuleWrapper::new(Rc::clone(&env));
            let counter1 = ModuleWrapper::new(Rc::clone(&env));
            let counter2 = ModuleWrapper::new(Rc::clone(&env));
            let counter3 = ModuleWrapper::new(Rc::clone(&env));
            let counter4 = ModuleWrapper::new(Rc::clone(&env));
            let counter5 = ModuleWrapper::new(Rc::clone(&env));
            let counter6 = ModuleWrapper::new(Rc::clone(&env));
            let counter7 = ModuleWrapper::new(Rc::clone(&env));
            let counter8 = ModuleWrapper::new(Rc::clone(&env));
            let counter9 = ModuleWrapper::new(Rc::clone(&env));
            let counters = Mapping::new(Rc::clone(&env));
            let counters_map = Mapping::new(Rc::clone(&env));
            Self {
                env,
                counter0,
                counter1,
                counter2,
                counter3,
                counter4,
                counter5,
                counter6,
                counter7,
                counter8,
                counter9,
                counters,
                counters_map
            }
        }

        fn env(&self) -> &ContractEnv {
            &self.env
        }
    }
}

#[cfg(odra_core_module = "CounterPack")]
mod wasm_parts {
    use alloc::rc::Rc;
    use alloc::vec::Vec;
    use casper_contract::contract_api::runtime;
    use casper_contract::unwrap_or_revert::UnwrapOrRevert;
    use casper_types::{EntryPoints, EntryPoint, CLType, EntryPointAccess, EntryPointType, CLValue, Parameter};
    use odra_core::env::ContractEnv;
    use odra_core::module::Module;

    use super::CounterPack;

    extern crate alloc;

    pub fn entry_points() -> EntryPoints {
        let mut entry_points = EntryPoints::new();
        entry_points.add_entry_point(EntryPoint::new(
            "get_count",
            alloc::vec![
                Parameter::new(
                    "index_a",
                    CLType::U8
                ),
                Parameter::new(
                    "index_b",
                    CLType::U8
                ),
            ],
            CLType::U32,
            EntryPointAccess::Public,
            EntryPointType::Contract
        ));
        entry_points.add_entry_point(EntryPoint::new(
            "increment",
            alloc::vec![
                Parameter::new(
                    "index_a",
                    CLType::U8
                ),
                Parameter::new(
                    "index_b",
                    CLType::U8
                ),
            ],
            CLType::Unit,
            EntryPointAccess::Public,
            EntryPointType::Contract
        ));
        entry_points
    }
    
    pub fn execute_call() {
        odra_core::wasm_host::install_contract(entry_points(), Vec::new());
    }

    pub fn execute_get_count() {
        let index_a: u8 = runtime::get_named_arg("index_a");
        let index_b: u8 = runtime::get_named_arg("index_b");
        let env = ContractEnv::new(0);
        let contract: CounterPack = CounterPack::new(Rc::new(env));
        let result = contract.get_count( index_a, index_b);
        runtime::ret(CLValue::from_t(result).unwrap_or_revert());
    }

    pub fn execute_increment() {
        let env = ContractEnv::new(0);
        let index_a: u8 = runtime::get_named_arg("index_a");
        let index_b: u8 = runtime::get_named_arg("index_b");
        let mut contract: CounterPack = CounterPack::new(Rc::new(env));
        contract.increment(index_a, index_b);
    }
}

// autogenerated
#[cfg(odra_core_module = "CounterPack")]
mod wasm_exports {
    use super::wasm_parts;
    
    #[no_mangle]
    fn call() {
        wasm_parts::execute_call();
    }
    
    #[no_mangle]
    fn get_count() {
        wasm_parts::execute_get_count();
    }
    
    #[no_mangle]
    fn increment() {
        wasm_parts::execute_increment();
    }
}

